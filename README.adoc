[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/G801g4IR)
= Gestionnaire de Fichiers en Commandes en Ligne avec Annotations

Berhil, Ilyes,21916240,78

Bouabdallaoui, Zeyneb, 21904931,77
Kbayli, Yanis, 22005217
Mihet, Alexandre, 22005024
Billal, Medour, 21924103

https://github.com/ensYeh/miniprojet-grp-77_78

L'objet de ce mini-projet est de développer un https://fr.wikipedia.org/wiki/Gestionnaire_de_fichier[gestionnaire de fichiers] en commande en ligne. Le gestionnaire de fichier s'appuie sur le système de fichier de votre système d'exploitation. Le gestionnaire de fichier doit offrir la possibilité d'annoter les éléments contenus dans un répertoire (i.e.fichiers, répertoires).
Vous devrez respecter les contraintes fonctionnelles et techniques mentionnées ci-dessous.

[IMPORTANT]
====
Vous respecterez les contraintes suivantes:

* Ce mini-projet est à réaliser en Java par groupe de 2 étudiants.
  - les 2 étudiants doivent coopérer à travers un même git. Un des deux étudiants devra permettre à l'autre d'utiliser son git.
* Il devra comporter une documentation dans ce git.
  - La documentation devra décrire l'usage de l'application (_manuel utilisateur_) ainsi que la conception du jeu (_manuel technique_).
  - La documentation doit être un fichier .md ou .adoc et accessible depuis le `git`
* Vous utiliserez `git` en effectuant des commits réguliers comportant des messages informatifs. L'usage des "pull requests" est également fortement conseillé, montrant ainsi votre collaboration au sein du groupe. 
* Le _build_ sera assuré par Maven et plus précisément Maven wrapper (déjà intégré dans le projet).
Aucune manipulation en dehors de Maven ne devra être nécessaire.
* La version de Java à utiliser est la https://adoptium.net/[version 17].
* Le _build_ devra intégrer `checkstyle` pour la vérification des règles de codages Google.
Le projet devra donc les respecter.
`checkstyle` devra être exécuté automatiquement durant la phase `validate` du cycle de vie par défaut.
* Des tests unitaires https://junit.org/junit5/docs/current/user-guide/[JUnit 5] (version https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter/5.9.1[_5.9.1_]) devront être disponibles pour la plupart des méthodes développées.
* Un outil de https://fr.wikipedia.org/wiki/Couverture_de_code[_Code Coverage_] devra être intégré au _build_
* Les fonctionnalités du langage Java devront être utilisées au mieux (POO, exceptions, librairie de collections, I/O, …).
* L'application devra pouvoir être exécutée à partir d'un `jar` incluant toutes les dépendances.
====

== Description du gestionnaire de fichiers
* L'interface proposera une visualisation du contenu d'un répertoire en mode texte. A chaque élément du répertoire (**ER**), on associera un numero (**NER**) permettant de le designer lors de l'utilisation d'une des commandes définies ci-dessous.

* Les actions de l'utilisateur seront saisies au clavier sous la forme `[<NER>] [<commande>] [<nom>]`. Les crochets signifient "optionnel" 
  - Par exemples:
   ** `3 cut` ; efface le troisième fichier.
   ** `3`  ; l'utilisateur désigne le troisième élément du répertoire.
  - Si l'utilisateur ne place pas de NER, c'est le dernier NER utilisé qui sera utilisé pour une commande qui en nécessite. Exemple `visu`
  - Les commandes du gestion de fichiers à implémenter sont:
    - `[<NER>] copy`
    - `past`  ; si l’élément existe, alors le nom du nouvel élément sera concaténé avec "-copy"
    - `[<NER>] cut`
    - `..` ; pour remonter d'un cran dans le système de fichiers
    - `[<NER>] .` ; pour entrer dans un répertoire à condition que le NER désigne un répertoire. Exemple "4 ."
    - `mkdir <nom>` ; pour créer un répertoire
    - `[<NER>] visu` ; permet de voir le contenu d'un fichier texte. Si le fichier n'est pas de type texte, vous afficherez sa taille.
    - `find <nom fichier>` ; Recherche dans toutes les sous répertoires du répertoire courant, le(s) fichier(s) et les affiches.

* L'application permettra à l'utilisateur d'annoter un ER
  - l'annotation consiste à ajouter ou retirer un texte associé à un ER. 
  - Par exemples:
       ** 3 + "ceci est un texte" ; le texte est ajouté ou concaténé au texte existant sur l'ER
       ** 3 -  ; retire tout le texte associé à l'ER 3

 

== Description de l'application à réaliser

* L'interface proposera une visualisation du répertoire courant en mode texte en quatre parties. La partie:
  . présente le cheminement depuis la racine du système de fichier de votre système de fichier.
  . affiche la note associée à l'élément courant NER si elle existe. L'élément courant correspond à la désignation du NER par l'utilisateur ou désigné dans la dernière commande utilisée. Exemple `3 copy`, 3 devient l'élément courant.
  . affiche les ER du répertoire avec leurs NER
  . présente un prompt invitant l'utilisateur à saisir une des commandes présentées ci-dessus.

* Une interface spécifique pourra être proposée pour des situations particulières (visualiser le contenu d'un fichier, une aide, ...).

* Toutes les notes associées aux éléments du répertoire courant seront stockés dans un seul fichier appelé "notes" dans le répertoire courant. Ce fichier peut contenir des objets "sérialisés" ou d'autres formats.



== Références
* Article Wikipedia https://fr.wikipedia.org/wiki/Gestionnaire_de_fichiers[Gestionnaire de fichiers]

* Quelques bibliothèques :
http://fusesource.github.io/jansi/[JAnsi] (couleur dans un terminal),
https://github.com/jline/jline3[JLine] (gestion des saisies)

== Manuel utilisateur

> À compléter :
> Comment l'utilisateur peut savoir quelle commande taper pour un élément du répertoire désigné ?

Nous avons implémenté une fonctionnalité 'help' sous forme de commande. Lorsque l'utilisateur l'executera, il lui
sera affiché sur le terminal une liste des commandes avec leur syntaxe et une description.

> Quelles sont les mises à jours du fichier des annotations à effectuer en fonction des types de commandes ?

- Lorsqu'un utilisateur ajoute une annotation à un élément, le fichier des annotations est mis à jour en ajoutant 
  une entrée associant le chemin de l'élément avec l'annotation.
- Lorsqu'un utilisateur supprime une annotation, l'entrée correspondante dans le fichier des annotations est supprimée.

> Y a t il des bibliothèques Java qui permettront de prendre en charge la visualisation d'une image png si l'utilisateur veut l'afficher ? 

Oui, il existe plusieurs bibliothèques Java qui permettent de prendre en charge la visualisation d'une image PNG
Comme par exemple : Swing (javax.swing) ; JavaFX ; AWT (java.awt) ; Thumbnails API (javax.imageio)

> Quelles sont les commandes qui seraient utiles de rajouter ?
 
- rm pour supprimer (que l'on a ajouté).
- touch pour créer un fichier (que l'on a ajouté).
- mv pour déplacer un fichier ou un dossier et tout son contenu (arborescence).
- rename pour renommer un fichier 

> Quelles améliorations peut on envisager pour rendre l'usage de l'interface clavier plus souples/efficaces pour l'utilisateur ?

Pour rendre l'interface clavier plus souple et efficace voici quelques suggestions :
  Auto-complétion et suggestion :
    Mettre en place une fonction d'auto-complétion pour les commandes et les chemins de fichiers. Cela simplifie 
    la saisie en proposant des options basées sur la frappe de l'utilisateur.
  Historique des commandes :
    Intégrer un historique des commandes pour permettre à l'utilisateur de parcourir et réutiliser facilement les 
    commandes précédemment saisies.
  Raccourcis clavier :
    Proposer des raccourcis clavier intuitifs pour les commandes fréquemment utilisées, offrant ainsi une méthode 
    rapide d'exécution des actions courantes.
  Commandes interactives :
    Implémenter des mécanismes de confirmation pour les actions potentiellement risquées, minimisant ainsi les 
    erreurs d'exécution.
  Personnalisation :
    Permettre à l'utilisateur de personnaliser son expérience en configurant des préférences telles que les 
    raccourcis clavier et l'apparence de l'interface.
  Mode plein écran :
    Ajouter une fonctionnalité de basculement entre le mode plein écran et le mode fenêtré pour s'adapter aux 
    préférences de l'utilisateur en matière d'interface.

> Quelles évolutions peut-on envisager ? Nous pouvons rename un dossier ou fichier. 

L'intégration d'une fonctionnalité de renommage des éléments constitue une évolution importante. 
Cela permettrait à l'utilisateur de modifier les noms des éléments dans le système de fichiers de manière 
intuitive. En ajoutant cette fonctionnalité, l'application devrait fournir une commande spécifique (par exemple, 
"rename" ou "mv") qui prend en charge le renommage en permettant à l'utilisateur de spécifier via le NER l'élément 
concerné et le nouveau nom. Un mécanisme de confirmation peut être envisagé pour éviter les changements 
involontaires. Cette fonctionnalité améliorerait la flexibilité et la gestion des éléments dans l'interface en ligne 
de commande.

== Manuel technique
=== Compiler le projet
.Sous Linux
----
$ ./mvnw package
----

.Sous Windows
----
> mvnw.cmd package
----

=== Exécuter l'application
----
---- Dans le powershell---
$ mvn clean compile assembly:single
$ java -jar .\target\explorer-1.0-SNAPSHOT-jar-with-dependencies.jar
----
----- Pour vérifier les erreurs de checkstyle---
$ mvn checkstyle:check
-----

> À compléter :
> Comment consulter le rapport de couverture de code par les tests ?

En éxecutant la commande $ mvn test dans un terminal une fois cette commande exécutée, le rapport 
généré se trouvera dans le répertoire target/site/jacoco/index.html. En ouvrant ce fichier dans 
un navigateur web on peut consulter le rapport de couverture. 

> Quelles bibliothèques ont été utilisées et pourquoi ?
java.time.LocalDateTime: Utilisée pour travailler avec des dates et heures.
java.util.ArrayList, java.util.HashMap, java.util.List, java.util.Map: Utilisées pour la manipulation de 
collections de données (listes, maps, etc.).
java.io.File: Utilisée pour interagir avec le système de fichiers, créer des fichiers, obtenir des informations 
sur les fichiers, etc.
java.nio.file.Files, java.nio.file.Path, java.nio.file.Paths: Utilisées pour travailler avec les opérations de 
fichiers et de chemins.
java.nio.file.FileVisitResult, java.nio.file.SimpleFileVisitor, java.nio.file.StandardCopyOption, 
java.nio.file.attribute.BasicFileAttributes: Utilisées pour la gestion des visites de fichiers et des attributs 
de fichiers.

Package org.apache.commons.io:
  org.apache.commons.io.FilenameUtils: Utilisée pour travailler avec les noms de fichiers et les chemins de 
  fichiers de manière simplifiée.

Package com.google.gson:
  com.google.gson.Gson, com.google.gson.reflect.TypeToken: Utilisées pour la sérialisation et la désérialisation 
  d'objets Java en JSON.

Package org.jline.reader, org.jline.terminal:
  org.jline.reader.*, org.jline.reader.impl.completer.*, org.jline.terminal.Terminal, 
  org.jline.terminal.TerminalBuilder: Utilisées pour la création d'une interface utilisateur en ligne de commande 
  interactive.

Package org.junit.jupiter.api:
  org.junit.jupiter.api.Assertions: Utilisée pour les assertions dans les tests unitaires.
  org.junit.jupiter.api.Test: Utilisée pour l'annotation des méthodes de test.

> Quel est le rôle des différentes classes ?
- La super classe Entite: Cette classe possede une grande des méthodes y sont 'rm', 'copy', 'paste', 'find' et 
  d'autres méthodes auxiliaires. Cette classe permet de définir tout les attributs communs aux classes Fichier 
  et Dossier, mais aussi toutes les méthodes dont elles ont besoin.

- La classe Fichier: Cette classe hérite de la classe Entite, elle permet la création des objets Fichier, si le fichier existe,
  elle crée simplement un objet qui lui est associé, sinon, elle crée également le fichier sur disque. On y retrouve 
  également des méthodes pour savoir si un fichier existe car la fonction proposée par java.io.File ne fonctionnait pas pour 
  les objets de type Ficher. Ces méthodes sont surtout utilisées lors des tests.

- La classe Dossier: Cette classe hérite aussi de la classe Entite, elle permet la création des objets Dossier, si le dossier existe,
  elle crée simplement un objet qui lui est associé, sinon, elle crée également le dossier sur disque. On y retrouve 
  également des méthodes pour savoir si un fdossier existe car la fonction proposée par java.io.File ne fonctionnait pas pour 
  les objets de type Dossier. Elle possede aussi une méthode estVide qui renvoie true si le dossier est vide et false sinon.
  Cette fonction à été implémentée pour la même raison que celles du dessus. Ces méthodes sont surtout utilisées lors des tests.

- La classe Systeme_Fichier: Cette classe offre des fonctionnalités pour interagir avec le système de fichiers. Elle permet de 
  définir et afficher le répertoire courant, lister le contenu d'un répertoire, naviguer dans les sous-répertoires, visualiser 
  le contenu des fichiers, et revenir au répertoire parent. Elle utilise des annotations et prend en charge la lecture de fichiers
  texte (.txt, .md, .adoc, .json) ainsi que l'affichage de la taille des autres types de fichiers. 

- La classe Annotation: Cette classe, gère les annotations associées aux éléments du répertoire courant. Elle utilise la bibliothèque
  Gson pour sérialiser et désérialiser les annotations au format JSON. Les méthodes incluent le chargement des annotations depuis un 
  fichier, l'ajout ou la suppression d'annotations pour des éléments spécifiques, la sauvegarde des annotations dans le fichier, et la
  récupération d'une annotation pour un chemin donné. L'emplacement du fichier de sauvegarde est défini comme "notes.json".

- La classe Command: Celle-ci permet de faire le lien entre l'utilisateur et les méthodes implémentées dans les autres classes.
Il prend en charge des commandes telles que la navigation, la visualisation du contenu des fichiers, la création de dossiers, la 
suppression d'éléments, la copie/coupe et le collage d'éléments, la recherche de fichiers, et l'ajout/suppression d'annotations. Cette 
classe utilise la bibliothèque JLine pour la lecture des commandes.

> Quels traitements sont réalisés pour gérer une commande saisie par l'utilisateur ? Donnez un exemple.

Pour gérer une commande saisie par l'utilisateur, le programme effectue les étapes suivantes dans la classe Command:
- Lecture de la commande : Utilisation de la bibliothèque JLine pour lire la commande entrée par l'utilisateur.
- Analyse de la commande : La commande est analysée pour extraire le NER (Numéro d'Élément de Répertoire), la commande elle-même et 
  les éventuels arguments.
- Traitement de la commande : En fonction de la commande identifiée, le programme effectue les actions appropriées. Par exemple, les 
  commandes peuvent inclure la navigation dans le répertoire, la visualisation du contenu des fichiers, la création de dossiers, la 
  suppression d'éléments, la copie/coupe et le collage d'éléments, la recherche de fichiers, et l'ajout/suppression d'annotations.
- Interaction avec les classes correspondantes : Les méthodes des classes Entite, Dossier, Fichier, Systeme_Fichier, et Annotation 
  sont appelées en fonction de la commande spécifiée. Ces classes contiennent les fonctionnalités nécessaires pour exécuter les 
  actions demandées.
voici un exemple: 
case "mkdir" :
    if (argument.isEmpty()){
        System.out.println("Vous n'avez pas renseigner de nom pour la création de dossier.");
    }else if (!argument.isEmpty()){
        new Dossier(argument, Systeme_Fichier.getRepertoireCourantString());
    }else {
        System.out.println("Erreur lors de la création du dossier.");
    }
    break;
Dans cet exemple, si l'utilisateur entre la commande "mkdir", le programme vérifie si un nom de dossier est spécifié en argument. 
Si c'est le cas, il crée un nouvel objet de type Dossier avec le nom spécifié dans le répertoire courant à l'aide de la classe 
Systeme_Fichier. Ensuite, le répertoire courant est listé à nouveau pour afficher le résultat de l'action.

> Quelles améliorations peut-on envisager ?

Concernant les améliorations, nous en avons intégrer certaines que nous avons considéré pertinentes:
- La méthode 'touch' qui permet de créer un fichier. Nous l'avons ajouté car cela nous semblait pertinentes
  puisque nous avions déja à implémenter la méthode 'mkdir' qui créer un dossier.

- Pour ces méthodes nous n'avons pas laissé ce choix à l'utilisateur, cependant les méthodes 'touch' et 'mkdir'
  qui sont en réalité respectivement des appels aux constructeurs des classes Fichier et Dossier, permettent de créer
  ces éléments depuis n'importe quel répertoire et vers n'importe quel répertoire tant que le chemin est spécifié.
  (Equivalent à touch src/main/.../toto.txt sous Linux qui créer le fichier à l'emplacement donné, idem pour mkdir).

- La méthode 'rm' qui supprime un fichier ou un dossier et tout son contenu (équivalent de 'rm -r [nom]' sous Linux).
  On a ajouté cette méthode pour offir la possibilité à l'utilisateur qui a déja le pouvoir de créer des fichiers
  ou des dossier de pouvoir les supprimer sans garder l'élément en mémoire. De plus cette méthode nous à été grandement 
  utile lors de la création des tests pour 'nettoyer' les fichiers crées mais surtout pour l'implémentation de la méthode
  cut qui à été triviale grâce à cela.

- Pour la méthode 'copy' (qui est aussi utilisée dans la méthode cut), nous nous sommes inspirés de ce que l'on peut 
  éxperimenter sur Windows avec l'utilisation d'un Presse-Papier qui nous permet de copier l'élément voulu une seule fois
  mais de pouvoir le coller autant de fois qu'on le souhaite. 

- En ce qui concerne la méthode 'paste' nous lui avons ajouté deux améliorations. La première, le nommage des éléments.
  En effet lors des premiers tests que nous avons éffectués, nous avions décidé de coller un fichier dix fois au même 
  emplacement. Sans surprise la dixième copie avait un nom comme celui-ci: 'nom-copy-copy-copy-copy...-copy', ce qui rend
  l'affichage surchargé et nuit à la visibilité en plus de ne pas être très pratique. Nous avons donc ajusté notre méthode
  de nommage pour qu'elle intégre au nom de la copie un index qui représente le nombre de fois où la copie de l'élément de 
  base est présente à l'emplacement. Ainsi, le nom de la dixième copie dans le même répertoire est 'nom-copy-10'. La deuxième
  amélioration faite à cette méthode est comme pour 'mkdir' et 'touch' de pouvoir coller en spécifiant un chemin (n'as pas été
  ajoutés aux possibilités de l'utilisateur).

- La méthode 'visu' qui doit initialement afficher le contenu d'un fichier txt ou la taille si ce n'est pas le cas, permet 
  d'afficher le contenu des fichiers suivants: txt, md, adoc et json.

- Nous avons également implémenté une fonctionnalité supplémentaire qui a été intégrée sous la forme de la commande 'help'. 
  Lorsqu'elle est utilisée, cette commande affiche à l'utilisateur une liste exhaustive des commandes disponibles, 
  leur syntaxe respective, ainsi qu'une description détaillée de l'action qu'elles permettent d'accomplir sur les éléments du 
  répertoire.

Pour les améliorations que nous aurions pu ajouter et que nous avons pas faites, nous pourrions envisager les points suivants:
- Ajouter le concept d'utilisateur pour pouvoir introduire la notion de droit sur les éléments.
- Ajouter une fonctionnalité pour déplacer des fichiers ou des dossiers d'un emplacement à un autre.
- Permettre aux utilisateurs de renommer des fichiers et des dossiers.
Ces points la sont les plus pertinents.